# -*- coding: utf-8 -*-
"""Course_task.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oalLBk6aBmwU0v86quaVq_88wkoG0COy
"""

# Загружаем Билиотеки
import csv
import os
import pickle
import codecs

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Подключаем Диск
from google.colab import drive
drive.mount('/content/drive')

# Файл с локациями 29 отправных точек
testLoc = '/content/drive/My Drive/datasets/tsp-data/bayg29-loc.pickle'
fn = open(testLoc, 'rb')
fn_loc = pickle.load(fn)
for i in fn_loc:
    print(i)

# Матрица с раcчетами растояния между локациями
testDist ='/content/drive/My Drive/datasets/tsp-data/bayg29-dist.pickle'
fd = open(testDist, 'rb')
fd_dist = pickle.load(fd)
for i in fd_dist:
    print(i)

# Парсинг данных из файлов
# Создание класса тестового маршрута
class TestRoute:

  def __init__(self, name):
    # переменные
    self.name = name
    self.locations = []
    self.distances = []
    self.tspSize = 0
    self.__initData ()

  # Длина маршрута
  def __len__(self):
    return self.tspSize

  # Чтение данных из файлов
  def __initData(self):
    try:
      self.locations = pickle.load(open(testLoc, 'rb'))
      self.distances = pickle.load(open(testDist, 'rb'))
    except (OSError, IOError):
      pass

    self.tspSize = len(self.locations)

  # Расчет Общей дистанции 
  def getTotalDistance(self, indices):
    distance = self.distances[indices[-1]][indices[0]]
    for i in range(len(indices) - 1):
      distance += self.distances[indices[i]][indices[i + 1]]

    return distance
  # Визуализация данных
  def plotData(self, indices):
    plt.scatter(*zip(*self.locations), marker='*', color='red')
    locs = [self.locations[i] for i in indices]
    locs.append(locs[0])
    plt.plot(*zip(*locs), linestyle='-', color='black')

    return plt



# Функция вывода тестового маршрута
def main():
    tsp = TestRoute("Тестовый маршрут")
    optimalSolution = [0, 27, 5, 11, 8, 25, 2, 28, 4, 20, 1, 19, 9, 3, 14, 17, 13, 16, 21, 10, 18, 24, 6, 22, 7, 26, 15, 12, 23]
    print(f"Название: {tsp.name}")
    print(f"Oптимальное решение: {optimalSolution}")
    print(f"Длина маршрута: {tsp.getTotalDistance(optimalSolution)}")
    # Визуализация маршрута
    plot = tsp.plotData(optimalSolution)
    plot.show()
main()

# Устанавливаем модуль для работы с генетическими алгоритмами
!pip install deap

!pip install tsp

"""Применение гинетического алгоритма"""

# Импортируем модуль
from deap import base
from deap import creator
from deap import tools
from deap import algorithms

import random
import array
import tsp

# Фиксированное начальное значение генератора случайных чисел
RANDOM_SEED = 42
random.seed(RANDOM_SEED)

# Переменные
TSP_NAME = "Тестовый маршрут"  
tsp = TestRoute(TSP_NAME)

# Константы генетического алгоритма
POPULATION_SIZE = 300 # количество индивидуумов в популяции
MAX_GENERATIONS = 200 # максимальное количество поколений
HALL_OF_FAME_SIZE = 1 # константы задачи
P_CROSSOVER = 0.9 # вероятность скрещивания
P_MUTATION = 0.1 # вероятность мутации индивидуума
toolbox = base.Toolbox() # класс Toolbox, который позволяет регистрировать новые функции
creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # класс Fitness,задача – минимизировать, то выбираем стратегию FitnessMin
creator.create("Individual", array.array, typecode='i', fitness=creator.FitnessMin) # для представления индивидуумов используется класс с  именем Individual
toolbox.register("randomOrder", random.sample, range(len(tsp)), len(tsp)) # оператор randomOrder В результате генерируется случайный список индексов от 0 до n – 1
toolbox.register("individualCreator", tools.initIterate, creator.Individual, toolbox.randomOrder) # оператор IndividualCreator. Он вызывает оператор randomOrder и обходит созданный им список с целью создать хромосому
toolbox.register("populationCreator", tools.initRepeat, list, toolbox.individualCreator) # оператор populationCreator, который порождает список индивидуумов, вызывая в цикле оператор IndividualCreator
# Реализовав хромосому, мы можем определить функцию вычисления приспособленности. 
# tspDistance(), которая вызывает метод getTotalDistance()
def tpsDistance(individual):
    return tsp.getTotalDistance(individual), 
toolbox.register("evaluate", tpsDistance)
# определение генетических операторов.
# будеми спользовать турнирный отбор с турниром размера 3
toolbox.register("select", tools.selTournament, tournsize=3) 
toolbox.register("mate", tools.cxOrdered)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=1.0/len(tsp))
toolbox.register("evaluate", tpsDistance)

# пользуемся встроенным в DEAP алгоритмом eaSimple и его объектами статистики и залом славы

def main():
    population = toolbox.populationCreator(n=POPULATION_SIZE)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("min", np.min)
    stats.register("avg", np.mean)
    hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
    population, logbook = algorithms.eaSimple(population, toolbox, cxpb=P_CROSSOVER, mutpb=P_MUTATION,
                                              ngen=MAX_GENERATIONS, stats=stats, halloffame=hof, verbose=True)
    best = hof.items[0]
    print(f"Лучший Вид Индивид: {best}")
    print(f"Лучший Фитнес: {best.fitness.values[0]}")

    plt.figure(1)
    tsp.plotData(best)

    minFitnessValues, meanFitnessValues = logbook.select("min", "avg")
    plt.figure(2)
    sns.set_style("whitegrid")
    plt.plot(minFitnessValues, color='red')
    plt.plot(meanFitnessValues, color='black')
    plt.xlabel('Генерация')
    plt.ylabel('Мин / Средняя Оценка')
    plt.title('Минимальная и средняя пригодность в течение нескольких поколений')
    
    plt.show()

main()

"""Дополнительное исследование"""

# модифицировать код алгоритма DEAP eaSimple(), поскольку каркас не дает прямого способа обойти эти операторы.

from deap import tools
from deap import algorithms

def eaSimpleWithElitism(population, toolbox, cxpb, mutpb, ngen, stats=None,
             halloffame=None, verbose=__debug__):
    """Этот алгоритм аналогичен алгоритму DEAP eaSimple (), с той модификацией, что
    halloffame используется для реализации механизма элитарности. Особи, содержащиеся в halloffame, 
    непосредственно вводятся в следующее поколение и не подвергаются
    генетическим операторам отбора, скрещивания и мутации."""
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])
    invalid_ind = [ind for ind in population if not ind.fitness.valid]
    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit
    if halloffame is None:
        raise ValueError("halloffame parameter must not be empty!")
    halloffame.update(population)
    hof_size = len(halloffame.items) if halloffame.items else 0
    record = stats.compile(population) if stats else {}
    logbook.record(gen=0, nevals=len(invalid_ind), **record)
    if verbose:
        print(logbook.stream)

    for gen in range(1, ngen + 1):
        offspring = toolbox.select(population, len(population) - hof_size)
        offspring = algorithms.varAnd(offspring, toolbox, cxpb, mutpb)
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit
        offspring.extend(halloffame.items)
        halloffame.update(offspring)
        population[:] = offspring
        record = stats.compile(population) if stats else {}
        logbook.record(gen=gen, nevals=len(invalid_ind), **record)
        if verbose:
            print(logbook.stream)
    return population, logbook

# Фиксированное начальное значение генератора случайных чисел
RANDOM_SEED = 42
random.seed(RANDOM_SEED)

TSP_NAME = "Тестовый маршрут с 500 поколениями"  
tsp = TestRoute(TSP_NAME)
# Константы генетического алгоритма
POPULATION_SIZE = 300 # количество индивидуумов в популяции
MAX_GENERATIONS = 500 # максимальное количество поколений
HALL_OF_FAME_SIZE = 30 # константы задачи
P_CROSSOVER = 0.9  # вероятность скрещивания
P_MUTATION = 0.1   # вероятность мутации индивидуума

toolbox = base.Toolbox() # класс Toolbox, который позволяет регистрировать новые функции
creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # класс Fitness,задача – минимизировать, то выбираем стратегию FitnessMin
creator.create("Individual", array.array, typecode='i', fitness=creator.FitnessMin) # для представления индивидуумов используется класс с  именем Individual
toolbox.register("randomOrder", random.sample, range(len(tsp)), len(tsp)) # оператор randomOrder В результате генерируется случайный список индексов от 0 до n – 1
toolbox.register("individualCreator", tools.initIterate, creator.Individual, toolbox.randomOrder) # оператор IndividualCreator. Он вызывает оператор randomOrder и обходит созданный им список с целью создать хромосому
toolbox.register("populationCreator", tools.initRepeat, list, toolbox.individualCreator)  # оператор populationCreator, который порождает список индивидуумов, вызывая в цикле оператор IndividualCreator
# Реализовав хромосому, мы можем определить функцию вычисления приспособленности. 
# tspDistance(), которая вызывает метод getTotalDistance()
def tpsDistance(individual):
    return tsp.getTotalDistance(individual),
# определение генетических операторов.
# будеми спользовать турнирный отбор с турниром размера 2
toolbox.register("evaluate", tpsDistance)
toolbox.register("select", tools.selTournament, tournsize=2)
toolbox.register("mate", tools.cxOrdered)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=1.0/len(tsp))


def main():
    population = toolbox.populationCreator(n=POPULATION_SIZE)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("min", np.min)
    stats.register("avg", np.mean)
    hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
    population, logbook = eaSimpleWithElitism(population, toolbox, cxpb=P_CROSSOVER, mutpb=P_MUTATION,
                                              ngen=MAX_GENERATIONS, stats=stats, halloffame=hof, verbose=True)
    best = hof.items[0]
    print(f"Лучший Вид Индивид: {best}")
    print(f"Лучший Фитнес: {best.fitness.values[0]}")

    plt.figure(1)
    tsp.plotData(best)
    minFitnessValues, meanFitnessValues = logbook.select("min", "avg")
    plt.figure(2)
    sns.set_style("whitegrid")
    plt.plot(minFitnessValues, color='red')
    plt.plot(meanFitnessValues, color='black')
    plt.xlabel('Генерация')
    plt.ylabel('Мин / Средняя Оценка')
    plt.title('Минимальная и средняя пригодность в течение нескольких поколений')
    plt.show()

main()